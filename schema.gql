# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateArtist {
  _avg: ArtistAvgAggregate
  _count: ArtistCountAggregate
  _max: ArtistMaxAggregate
  _min: ArtistMinAggregate
  _sum: ArtistSumAggregate
}

type AggregateEvents {
  _avg: EventsAvgAggregate
  _count: EventsCountAggregate
  _max: EventsMaxAggregate
  _min: EventsMinAggregate
  _sum: EventsSumAggregate
}

type AggregateSearchArtistsEventsLog {
  _avg: SearchArtistsEventsLogAvgAggregate
  _count: SearchArtistsEventsLogCountAggregate
  _max: SearchArtistsEventsLogMaxAggregate
  _min: SearchArtistsEventsLogMinAggregate
  _sum: SearchArtistsEventsLogSumAggregate
}

type AggregateTrackedArtist {
  _avg: TrackedArtistAvgAggregate
  _count: TrackedArtistCountAggregate
  _max: TrackedArtistMaxAggregate
  _min: TrackedArtistMinAggregate
  _sum: TrackedArtistSumAggregate
}

type AggregateUser {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
}

type Artist {
  Events(cursor: EventsWhereUniqueInput, distinct: [EventsScalarFieldEnum!], orderBy: [EventsOrderByWithRelationInput!], skip: Int, take: Int, where: EventsWhereInput): [Events!]!
  _count: ArtistCount
  createdAt: DateTime!
  id: Int!
  jobs(cursor: SearchArtistsEventsLogWhereUniqueInput, distinct: [SearchArtistsEventsLogScalarFieldEnum!], orderBy: [SearchArtistsEventsLogOrderByWithRelationInput!], skip: Int, take: Int, where: SearchArtistsEventsLogWhereInput): [SearchArtistsEventsLog!]!
  name: String!
  profileImg: String
  spotifyId: String!
  trackings(cursor: TrackedArtistWhereUniqueInput, distinct: [TrackedArtistScalarFieldEnum!], orderBy: [TrackedArtistOrderByWithRelationInput!], skip: Int, take: Int, where: TrackedArtistWhereInput): [TrackedArtist!]!
  updatedAt: DateTime!
}

type ArtistAvgAggregate {
  id: Float
}

input ArtistAvgOrderByAggregateInput {
  id: SortOrder
}

type ArtistCount {
  Events: Int!
  jobs: Int!
  trackings: Int!
}

type ArtistCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  name: Int!
  profileImg: Int!
  spotifyId: Int!
  updatedAt: Int!
}

input ArtistCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  updatedAt: SortOrder
}

input ArtistCreateInput {
  Events: EventsCreateNestedManyWithoutArtistInput
  createdAt: DateTime
  jobs: SearchArtistsEventsLogCreateNestedManyWithoutArtistInput
  name: String!
  profileImg: String
  spotifyId: String!
  trackings: TrackedArtistCreateNestedManyWithoutArtistInput
  updatedAt: DateTime
}

input ArtistCreateManyInput {
  createdAt: DateTime
  id: Int
  name: String!
  profileImg: String
  spotifyId: String!
  updatedAt: DateTime
}

input ArtistCreateNestedOneWithoutEventsInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutEventsInput
  create: ArtistCreateWithoutEventsInput
}

input ArtistCreateNestedOneWithoutJobsInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutJobsInput
  create: ArtistCreateWithoutJobsInput
}

input ArtistCreateNestedOneWithoutTrackingsInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutTrackingsInput
  create: ArtistCreateWithoutTrackingsInput
}

input ArtistCreateOrConnectWithoutEventsInput {
  create: ArtistCreateWithoutEventsInput!
  where: ArtistWhereUniqueInput!
}

input ArtistCreateOrConnectWithoutJobsInput {
  create: ArtistCreateWithoutJobsInput!
  where: ArtistWhereUniqueInput!
}

input ArtistCreateOrConnectWithoutTrackingsInput {
  create: ArtistCreateWithoutTrackingsInput!
  where: ArtistWhereUniqueInput!
}

input ArtistCreateWithoutEventsInput {
  createdAt: DateTime
  jobs: SearchArtistsEventsLogCreateNestedManyWithoutArtistInput
  name: String!
  profileImg: String
  spotifyId: String!
  trackings: TrackedArtistCreateNestedManyWithoutArtistInput
  updatedAt: DateTime
}

input ArtistCreateWithoutJobsInput {
  Events: EventsCreateNestedManyWithoutArtistInput
  createdAt: DateTime
  name: String!
  profileImg: String
  spotifyId: String!
  trackings: TrackedArtistCreateNestedManyWithoutArtistInput
  updatedAt: DateTime
}

input ArtistCreateWithoutTrackingsInput {
  Events: EventsCreateNestedManyWithoutArtistInput
  createdAt: DateTime
  jobs: SearchArtistsEventsLogCreateNestedManyWithoutArtistInput
  name: String!
  profileImg: String
  spotifyId: String!
  updatedAt: DateTime
}

type ArtistGroupBy {
  _avg: ArtistAvgAggregate
  _count: ArtistCountAggregate
  _max: ArtistMaxAggregate
  _min: ArtistMinAggregate
  _sum: ArtistSumAggregate
  createdAt: DateTime!
  id: Int!
  name: String!
  profileImg: String
  spotifyId: String!
  updatedAt: DateTime!
}

type ArtistMaxAggregate {
  createdAt: DateTime
  id: Int
  name: String
  profileImg: String
  spotifyId: String
  updatedAt: DateTime
}

input ArtistMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  updatedAt: SortOrder
}

type ArtistMinAggregate {
  createdAt: DateTime
  id: Int
  name: String
  profileImg: String
  spotifyId: String
  updatedAt: DateTime
}

input ArtistMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  updatedAt: SortOrder
}

input ArtistOrderByWithAggregationInput {
  _avg: ArtistAvgOrderByAggregateInput
  _count: ArtistCountOrderByAggregateInput
  _max: ArtistMaxOrderByAggregateInput
  _min: ArtistMinOrderByAggregateInput
  _sum: ArtistSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  name: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  updatedAt: SortOrder
}

input ArtistOrderByWithRelationInput {
  Events: EventsOrderByRelationAggregateInput
  createdAt: SortOrder
  id: SortOrder
  jobs: SearchArtistsEventsLogOrderByRelationAggregateInput
  name: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  trackings: TrackedArtistOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input ArtistRelationFilter {
  is: ArtistWhereInput
  isNot: ArtistWhereInput
}

enum ArtistScalarFieldEnum {
  createdAt
  id
  name
  profileImg
  spotifyId
  updatedAt
}

input ArtistScalarWhereWithAggregatesInput {
  AND: [ArtistScalarWhereWithAggregatesInput!]
  NOT: [ArtistScalarWhereWithAggregatesInput!]
  OR: [ArtistScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  profileImg: StringNullableWithAggregatesFilter
  spotifyId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type ArtistSumAggregate {
  id: Int
}

input ArtistSumOrderByAggregateInput {
  id: SortOrder
}

input ArtistUpdateInput {
  Events: EventsUpdateManyWithoutArtistNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  jobs: SearchArtistsEventsLogUpdateManyWithoutArtistNestedInput
  name: StringFieldUpdateOperationsInput
  profileImg: NullableStringFieldUpdateOperationsInput
  spotifyId: StringFieldUpdateOperationsInput
  trackings: TrackedArtistUpdateManyWithoutArtistNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ArtistUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  profileImg: NullableStringFieldUpdateOperationsInput
  spotifyId: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ArtistUpdateOneRequiredWithoutEventsNestedInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutEventsInput
  create: ArtistCreateWithoutEventsInput
  update: ArtistUpdateWithoutEventsInput
  upsert: ArtistUpsertWithoutEventsInput
}

input ArtistUpdateOneRequiredWithoutJobsNestedInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutJobsInput
  create: ArtistCreateWithoutJobsInput
  update: ArtistUpdateWithoutJobsInput
  upsert: ArtistUpsertWithoutJobsInput
}

input ArtistUpdateOneRequiredWithoutTrackingsNestedInput {
  connect: ArtistWhereUniqueInput
  connectOrCreate: ArtistCreateOrConnectWithoutTrackingsInput
  create: ArtistCreateWithoutTrackingsInput
  update: ArtistUpdateWithoutTrackingsInput
  upsert: ArtistUpsertWithoutTrackingsInput
}

input ArtistUpdateWithoutEventsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  jobs: SearchArtistsEventsLogUpdateManyWithoutArtistNestedInput
  name: StringFieldUpdateOperationsInput
  profileImg: NullableStringFieldUpdateOperationsInput
  spotifyId: StringFieldUpdateOperationsInput
  trackings: TrackedArtistUpdateManyWithoutArtistNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ArtistUpdateWithoutJobsInput {
  Events: EventsUpdateManyWithoutArtistNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  profileImg: NullableStringFieldUpdateOperationsInput
  spotifyId: StringFieldUpdateOperationsInput
  trackings: TrackedArtistUpdateManyWithoutArtistNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ArtistUpdateWithoutTrackingsInput {
  Events: EventsUpdateManyWithoutArtistNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  jobs: SearchArtistsEventsLogUpdateManyWithoutArtistNestedInput
  name: StringFieldUpdateOperationsInput
  profileImg: NullableStringFieldUpdateOperationsInput
  spotifyId: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input ArtistUpsertWithoutEventsInput {
  create: ArtistCreateWithoutEventsInput!
  update: ArtistUpdateWithoutEventsInput!
}

input ArtistUpsertWithoutJobsInput {
  create: ArtistCreateWithoutJobsInput!
  update: ArtistUpdateWithoutJobsInput!
}

input ArtistUpsertWithoutTrackingsInput {
  create: ArtistCreateWithoutTrackingsInput!
  update: ArtistUpdateWithoutTrackingsInput!
}

input ArtistWhereInput {
  AND: [ArtistWhereInput!]
  Events: EventsListRelationFilter
  NOT: [ArtistWhereInput!]
  OR: [ArtistWhereInput!]
  createdAt: DateTimeFilter
  id: IntFilter
  jobs: SearchArtistsEventsLogListRelationFilter
  name: StringFilter
  profileImg: StringNullableFilter
  spotifyId: StringFilter
  trackings: TrackedArtistListRelationFilter
  updatedAt: DateTimeFilter
}

input ArtistWhereUniqueInput {
  id: Int
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

type Events {
  artist: Artist!
  artistId: Int!
  createdAt: DateTime!
  date: String!
  description: String
  dueDate: DateTime!
  id: Int!
  location: String!
  name: String!
  updatedAt: DateTime!
}

type EventsAvgAggregate {
  artistId: Float
  id: Float
}

input EventsAvgOrderByAggregateInput {
  artistId: SortOrder
  id: SortOrder
}

type EventsCountAggregate {
  _all: Int!
  artistId: Int!
  createdAt: Int!
  date: Int!
  description: Int!
  dueDate: Int!
  id: Int!
  location: Int!
  name: Int!
  updatedAt: Int!
}

input EventsCountOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  dueDate: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input EventsCreateInput {
  artist: ArtistCreateNestedOneWithoutEventsInput!
  createdAt: DateTime
  date: String!
  description: String
  dueDate: DateTime!
  location: String!
  name: String!
  updatedAt: DateTime
}

input EventsCreateManyArtistInput {
  createdAt: DateTime
  date: String!
  description: String
  dueDate: DateTime!
  id: Int
  location: String!
  name: String!
  updatedAt: DateTime
}

input EventsCreateManyArtistInputEnvelope {
  data: [EventsCreateManyArtistInput!]!
  skipDuplicates: Boolean
}

input EventsCreateManyInput {
  artistId: Int!
  createdAt: DateTime
  date: String!
  description: String
  dueDate: DateTime!
  id: Int
  location: String!
  name: String!
  updatedAt: DateTime
}

input EventsCreateNestedManyWithoutArtistInput {
  connect: [EventsWhereUniqueInput!]
  connectOrCreate: [EventsCreateOrConnectWithoutArtistInput!]
  create: [EventsCreateWithoutArtistInput!]
  createMany: EventsCreateManyArtistInputEnvelope
}

input EventsCreateOrConnectWithoutArtistInput {
  create: EventsCreateWithoutArtistInput!
  where: EventsWhereUniqueInput!
}

input EventsCreateWithoutArtistInput {
  createdAt: DateTime
  date: String!
  description: String
  dueDate: DateTime!
  location: String!
  name: String!
  updatedAt: DateTime
}

type EventsGroupBy {
  _avg: EventsAvgAggregate
  _count: EventsCountAggregate
  _max: EventsMaxAggregate
  _min: EventsMinAggregate
  _sum: EventsSumAggregate
  artistId: Int!
  createdAt: DateTime!
  date: String!
  description: String
  dueDate: DateTime!
  id: Int!
  location: String!
  name: String!
  updatedAt: DateTime!
}

input EventsListRelationFilter {
  every: EventsWhereInput
  none: EventsWhereInput
  some: EventsWhereInput
}

type EventsMaxAggregate {
  artistId: Int
  createdAt: DateTime
  date: String
  description: String
  dueDate: DateTime
  id: Int
  location: String
  name: String
  updatedAt: DateTime
}

input EventsMaxOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  dueDate: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

type EventsMinAggregate {
  artistId: Int
  createdAt: DateTime
  date: String
  description: String
  dueDate: DateTime
  id: Int
  location: String
  name: String
  updatedAt: DateTime
}

input EventsMinOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  dueDate: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input EventsOrderByRelationAggregateInput {
  _count: SortOrder
}

input EventsOrderByWithAggregationInput {
  _avg: EventsAvgOrderByAggregateInput
  _count: EventsCountOrderByAggregateInput
  _max: EventsMaxOrderByAggregateInput
  _min: EventsMinOrderByAggregateInput
  _sum: EventsSumOrderByAggregateInput
  artistId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  dueDate: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

input EventsOrderByWithRelationInput {
  artist: ArtistOrderByWithRelationInput
  artistId: SortOrder
  createdAt: SortOrder
  date: SortOrder
  description: SortOrder
  dueDate: SortOrder
  id: SortOrder
  location: SortOrder
  name: SortOrder
  updatedAt: SortOrder
}

enum EventsScalarFieldEnum {
  artistId
  createdAt
  date
  description
  dueDate
  id
  location
  name
  updatedAt
}

input EventsScalarWhereInput {
  AND: [EventsScalarWhereInput!]
  NOT: [EventsScalarWhereInput!]
  OR: [EventsScalarWhereInput!]
  artistId: IntFilter
  createdAt: DateTimeFilter
  date: StringFilter
  description: StringNullableFilter
  dueDate: DateTimeFilter
  id: IntFilter
  location: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input EventsScalarWhereWithAggregatesInput {
  AND: [EventsScalarWhereWithAggregatesInput!]
  NOT: [EventsScalarWhereWithAggregatesInput!]
  OR: [EventsScalarWhereWithAggregatesInput!]
  artistId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  date: StringWithAggregatesFilter
  description: StringNullableWithAggregatesFilter
  dueDate: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  location: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type EventsSumAggregate {
  artistId: Int
  id: Int
}

input EventsSumOrderByAggregateInput {
  artistId: SortOrder
  id: SortOrder
}

input EventsUpdateInput {
  artist: ArtistUpdateOneRequiredWithoutEventsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  date: StringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  dueDate: DateTimeFieldUpdateOperationsInput
  location: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input EventsUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: StringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  dueDate: DateTimeFieldUpdateOperationsInput
  location: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input EventsUpdateManyWithWhereWithoutArtistInput {
  data: EventsUpdateManyMutationInput!
  where: EventsScalarWhereInput!
}

input EventsUpdateManyWithoutArtistNestedInput {
  connect: [EventsWhereUniqueInput!]
  connectOrCreate: [EventsCreateOrConnectWithoutArtistInput!]
  create: [EventsCreateWithoutArtistInput!]
  createMany: EventsCreateManyArtistInputEnvelope
  delete: [EventsWhereUniqueInput!]
  deleteMany: [EventsScalarWhereInput!]
  disconnect: [EventsWhereUniqueInput!]
  set: [EventsWhereUniqueInput!]
  update: [EventsUpdateWithWhereUniqueWithoutArtistInput!]
  updateMany: [EventsUpdateManyWithWhereWithoutArtistInput!]
  upsert: [EventsUpsertWithWhereUniqueWithoutArtistInput!]
}

input EventsUpdateWithWhereUniqueWithoutArtistInput {
  data: EventsUpdateWithoutArtistInput!
  where: EventsWhereUniqueInput!
}

input EventsUpdateWithoutArtistInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  date: StringFieldUpdateOperationsInput
  description: NullableStringFieldUpdateOperationsInput
  dueDate: DateTimeFieldUpdateOperationsInput
  location: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input EventsUpsertWithWhereUniqueWithoutArtistInput {
  create: EventsCreateWithoutArtistInput!
  update: EventsUpdateWithoutArtistInput!
  where: EventsWhereUniqueInput!
}

input EventsWhereInput {
  AND: [EventsWhereInput!]
  NOT: [EventsWhereInput!]
  OR: [EventsWhereInput!]
  artist: ArtistRelationFilter
  artistId: IntFilter
  createdAt: DateTimeFilter
  date: StringFilter
  description: StringNullableFilter
  dueDate: DateTimeFilter
  id: IntFilter
  location: StringFilter
  name: StringFilter
  updatedAt: DateTimeFilter
}

input EventsWhereUniqueInput {
  id: Int
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

input JsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input JsonWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedJsonFilter
  _min: NestedJsonFilter
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

type Mutation {
  createManyArtist(data: [ArtistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyEvents(data: [EventsCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManySearchArtistsEventsLog(data: [SearchArtistsEventsLogCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyTrackedArtist(data: [TrackedArtistCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneArtist(data: ArtistCreateInput!): Artist!
  createOneEvents(data: EventsCreateInput!): Events!
  createOneSearchArtistsEventsLog(data: SearchArtistsEventsLogCreateInput!): SearchArtistsEventsLog!
  createOneTrackedArtist(data: TrackedArtistCreateInput!): TrackedArtist!
  createOneUser(data: UserCreateInput!): User!
  deleteManyArtist(where: ArtistWhereInput): AffectedRowsOutput!
  deleteManyEvents(where: EventsWhereInput): AffectedRowsOutput!
  deleteManySearchArtistsEventsLog(where: SearchArtistsEventsLogWhereInput): AffectedRowsOutput!
  deleteManyTrackedArtist(where: TrackedArtistWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteOneArtist(where: ArtistWhereUniqueInput!): Artist
  deleteOneEvents(where: EventsWhereUniqueInput!): Events
  deleteOneSearchArtistsEventsLog(where: SearchArtistsEventsLogWhereUniqueInput!): SearchArtistsEventsLog
  deleteOneTrackedArtist(where: TrackedArtistWhereUniqueInput!): TrackedArtist
  deleteOneUser(where: UserWhereUniqueInput!): User
  updateManyArtist(data: ArtistUpdateManyMutationInput!, where: ArtistWhereInput): AffectedRowsOutput!
  updateManyEvents(data: EventsUpdateManyMutationInput!, where: EventsWhereInput): AffectedRowsOutput!
  updateManySearchArtistsEventsLog(data: SearchArtistsEventsLogUpdateManyMutationInput!, where: SearchArtistsEventsLogWhereInput): AffectedRowsOutput!
  updateManyTrackedArtist(data: TrackedArtistUpdateManyMutationInput!, where: TrackedArtistWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateOneArtist(data: ArtistUpdateInput!, where: ArtistWhereUniqueInput!): Artist
  updateOneEvents(data: EventsUpdateInput!, where: EventsWhereUniqueInput!): Events
  updateOneSearchArtistsEventsLog(data: SearchArtistsEventsLogUpdateInput!, where: SearchArtistsEventsLogWhereUniqueInput!): SearchArtistsEventsLog
  updateOneTrackedArtist(data: TrackedArtistUpdateInput!, where: TrackedArtistWhereUniqueInput!): TrackedArtist
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  upsertOneArtist(create: ArtistCreateInput!, update: ArtistUpdateInput!, where: ArtistWhereUniqueInput!): Artist!
  upsertOneEvents(create: EventsCreateInput!, update: EventsUpdateInput!, where: EventsWhereUniqueInput!): Events!
  upsertOneSearchArtistsEventsLog(create: SearchArtistsEventsLogCreateInput!, update: SearchArtistsEventsLogUpdateInput!, where: SearchArtistsEventsLogWhereUniqueInput!): SearchArtistsEventsLog!
  upsertOneTrackedArtist(create: TrackedArtistCreateInput!, update: TrackedArtistUpdateInput!, where: TrackedArtistWhereUniqueInput!): TrackedArtist!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedJsonFilter {
  array_contains: JSON
  array_ends_with: JSON
  array_starts_with: JSON
  equals: JSON
  gt: JSON
  gte: JSON
  lt: JSON
  lte: JSON
  not: JSON
  path: [String!]
  string_contains: String
  string_ends_with: String
  string_starts_with: String
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Query {
  aggregateArtist(cursor: ArtistWhereUniqueInput, orderBy: [ArtistOrderByWithRelationInput!], skip: Int, take: Int, where: ArtistWhereInput): AggregateArtist!
  aggregateEvents(cursor: EventsWhereUniqueInput, orderBy: [EventsOrderByWithRelationInput!], skip: Int, take: Int, where: EventsWhereInput): AggregateEvents!
  aggregateSearchArtistsEventsLog(cursor: SearchArtistsEventsLogWhereUniqueInput, orderBy: [SearchArtistsEventsLogOrderByWithRelationInput!], skip: Int, take: Int, where: SearchArtistsEventsLogWhereInput): AggregateSearchArtistsEventsLog!
  aggregateTrackedArtist(cursor: TrackedArtistWhereUniqueInput, orderBy: [TrackedArtistOrderByWithRelationInput!], skip: Int, take: Int, where: TrackedArtistWhereInput): AggregateTrackedArtist!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  artist(where: ArtistWhereUniqueInput!): Artist
  artists(cursor: ArtistWhereUniqueInput, distinct: [ArtistScalarFieldEnum!], orderBy: [ArtistOrderByWithRelationInput!], skip: Int, take: Int, where: ArtistWhereInput): [Artist!]!
  findFirstArtist(cursor: ArtistWhereUniqueInput, distinct: [ArtistScalarFieldEnum!], orderBy: [ArtistOrderByWithRelationInput!], skip: Int, take: Int, where: ArtistWhereInput): Artist
  findFirstEvents(cursor: EventsWhereUniqueInput, distinct: [EventsScalarFieldEnum!], orderBy: [EventsOrderByWithRelationInput!], skip: Int, take: Int, where: EventsWhereInput): Events
  findFirstSearchArtistsEventsLog(cursor: SearchArtistsEventsLogWhereUniqueInput, distinct: [SearchArtistsEventsLogScalarFieldEnum!], orderBy: [SearchArtistsEventsLogOrderByWithRelationInput!], skip: Int, take: Int, where: SearchArtistsEventsLogWhereInput): SearchArtistsEventsLog
  findFirstTrackedArtist(cursor: TrackedArtistWhereUniqueInput, distinct: [TrackedArtistScalarFieldEnum!], orderBy: [TrackedArtistOrderByWithRelationInput!], skip: Int, take: Int, where: TrackedArtistWhereInput): TrackedArtist
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findManyEvents(cursor: EventsWhereUniqueInput, distinct: [EventsScalarFieldEnum!], orderBy: [EventsOrderByWithRelationInput!], skip: Int, take: Int, where: EventsWhereInput): [Events!]!
  findUniqueEvents(where: EventsWhereUniqueInput!): Events
  groupByArtist(by: [ArtistScalarFieldEnum!]!, having: ArtistScalarWhereWithAggregatesInput, orderBy: [ArtistOrderByWithAggregationInput!], skip: Int, take: Int, where: ArtistWhereInput): [ArtistGroupBy!]!
  groupByEvents(by: [EventsScalarFieldEnum!]!, having: EventsScalarWhereWithAggregatesInput, orderBy: [EventsOrderByWithAggregationInput!], skip: Int, take: Int, where: EventsWhereInput): [EventsGroupBy!]!
  groupBySearchArtistsEventsLog(by: [SearchArtistsEventsLogScalarFieldEnum!]!, having: SearchArtistsEventsLogScalarWhereWithAggregatesInput, orderBy: [SearchArtistsEventsLogOrderByWithAggregationInput!], skip: Int, take: Int, where: SearchArtistsEventsLogWhereInput): [SearchArtistsEventsLogGroupBy!]!
  groupByTrackedArtist(by: [TrackedArtistScalarFieldEnum!]!, having: TrackedArtistScalarWhereWithAggregatesInput, orderBy: [TrackedArtistOrderByWithAggregationInput!], skip: Int, take: Int, where: TrackedArtistWhereInput): [TrackedArtistGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  searchArtistsEventsLog(where: SearchArtistsEventsLogWhereUniqueInput!): SearchArtistsEventsLog
  searchArtistsEventsLogs(cursor: SearchArtistsEventsLogWhereUniqueInput, distinct: [SearchArtistsEventsLogScalarFieldEnum!], orderBy: [SearchArtistsEventsLogOrderByWithRelationInput!], skip: Int, take: Int, where: SearchArtistsEventsLogWhereInput): [SearchArtistsEventsLog!]!
  trackedArtist(where: TrackedArtistWhereUniqueInput!): TrackedArtist
  trackedArtists(cursor: TrackedArtistWhereUniqueInput, distinct: [TrackedArtistScalarFieldEnum!], orderBy: [TrackedArtistOrderByWithRelationInput!], skip: Int, take: Int, where: TrackedArtistWhereInput): [TrackedArtist!]!
  user(where: UserWhereUniqueInput!): User
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum QueryMode {
  default
  insensitive
}

type SearchArtistsEventsLog {
  artist: Artist!
  artistId: Int!
  createdAt: DateTime!
  id: Int!
  jobId: Int!
  metadata: JSON!
  updatedAt: DateTime!
}

type SearchArtistsEventsLogAvgAggregate {
  artistId: Float
  id: Float
  jobId: Float
}

input SearchArtistsEventsLogAvgOrderByAggregateInput {
  artistId: SortOrder
  id: SortOrder
  jobId: SortOrder
}

type SearchArtistsEventsLogCountAggregate {
  _all: Int!
  artistId: Int!
  createdAt: Int!
  id: Int!
  jobId: Int!
  metadata: Int!
  updatedAt: Int!
}

input SearchArtistsEventsLogCountOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  jobId: SortOrder
  metadata: SortOrder
  updatedAt: SortOrder
}

input SearchArtistsEventsLogCreateInput {
  artist: ArtistCreateNestedOneWithoutJobsInput!
  createdAt: DateTime
  jobId: Int!
  metadata: JSON!
  updatedAt: DateTime
}

input SearchArtistsEventsLogCreateManyArtistInput {
  createdAt: DateTime
  id: Int
  jobId: Int!
  metadata: JSON!
  updatedAt: DateTime
}

input SearchArtistsEventsLogCreateManyArtistInputEnvelope {
  data: [SearchArtistsEventsLogCreateManyArtistInput!]!
  skipDuplicates: Boolean
}

input SearchArtistsEventsLogCreateManyInput {
  artistId: Int!
  createdAt: DateTime
  id: Int
  jobId: Int!
  metadata: JSON!
  updatedAt: DateTime
}

input SearchArtistsEventsLogCreateNestedManyWithoutArtistInput {
  connect: [SearchArtistsEventsLogWhereUniqueInput!]
  connectOrCreate: [SearchArtistsEventsLogCreateOrConnectWithoutArtistInput!]
  create: [SearchArtistsEventsLogCreateWithoutArtistInput!]
  createMany: SearchArtistsEventsLogCreateManyArtistInputEnvelope
}

input SearchArtistsEventsLogCreateOrConnectWithoutArtistInput {
  create: SearchArtistsEventsLogCreateWithoutArtistInput!
  where: SearchArtistsEventsLogWhereUniqueInput!
}

input SearchArtistsEventsLogCreateWithoutArtistInput {
  createdAt: DateTime
  jobId: Int!
  metadata: JSON!
  updatedAt: DateTime
}

type SearchArtistsEventsLogGroupBy {
  _avg: SearchArtistsEventsLogAvgAggregate
  _count: SearchArtistsEventsLogCountAggregate
  _max: SearchArtistsEventsLogMaxAggregate
  _min: SearchArtistsEventsLogMinAggregate
  _sum: SearchArtistsEventsLogSumAggregate
  artistId: Int!
  createdAt: DateTime!
  id: Int!
  jobId: Int!
  metadata: JSON!
  updatedAt: DateTime!
}

input SearchArtistsEventsLogListRelationFilter {
  every: SearchArtistsEventsLogWhereInput
  none: SearchArtistsEventsLogWhereInput
  some: SearchArtistsEventsLogWhereInput
}

type SearchArtistsEventsLogMaxAggregate {
  artistId: Int
  createdAt: DateTime
  id: Int
  jobId: Int
  updatedAt: DateTime
}

input SearchArtistsEventsLogMaxOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  jobId: SortOrder
  updatedAt: SortOrder
}

type SearchArtistsEventsLogMinAggregate {
  artistId: Int
  createdAt: DateTime
  id: Int
  jobId: Int
  updatedAt: DateTime
}

input SearchArtistsEventsLogMinOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  jobId: SortOrder
  updatedAt: SortOrder
}

input SearchArtistsEventsLogOrderByRelationAggregateInput {
  _count: SortOrder
}

input SearchArtistsEventsLogOrderByWithAggregationInput {
  _avg: SearchArtistsEventsLogAvgOrderByAggregateInput
  _count: SearchArtistsEventsLogCountOrderByAggregateInput
  _max: SearchArtistsEventsLogMaxOrderByAggregateInput
  _min: SearchArtistsEventsLogMinOrderByAggregateInput
  _sum: SearchArtistsEventsLogSumOrderByAggregateInput
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  jobId: SortOrder
  metadata: SortOrder
  updatedAt: SortOrder
}

input SearchArtistsEventsLogOrderByWithRelationInput {
  artist: ArtistOrderByWithRelationInput
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  jobId: SortOrder
  metadata: SortOrder
  updatedAt: SortOrder
}

enum SearchArtistsEventsLogScalarFieldEnum {
  artistId
  createdAt
  id
  jobId
  metadata
  updatedAt
}

input SearchArtistsEventsLogScalarWhereInput {
  AND: [SearchArtistsEventsLogScalarWhereInput!]
  NOT: [SearchArtistsEventsLogScalarWhereInput!]
  OR: [SearchArtistsEventsLogScalarWhereInput!]
  artistId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  jobId: IntFilter
  metadata: JsonFilter
  updatedAt: DateTimeFilter
}

input SearchArtistsEventsLogScalarWhereWithAggregatesInput {
  AND: [SearchArtistsEventsLogScalarWhereWithAggregatesInput!]
  NOT: [SearchArtistsEventsLogScalarWhereWithAggregatesInput!]
  OR: [SearchArtistsEventsLogScalarWhereWithAggregatesInput!]
  artistId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  jobId: IntWithAggregatesFilter
  metadata: JsonWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type SearchArtistsEventsLogSumAggregate {
  artistId: Int
  id: Int
  jobId: Int
}

input SearchArtistsEventsLogSumOrderByAggregateInput {
  artistId: SortOrder
  id: SortOrder
  jobId: SortOrder
}

input SearchArtistsEventsLogUpdateInput {
  artist: ArtistUpdateOneRequiredWithoutJobsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  jobId: IntFieldUpdateOperationsInput
  metadata: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SearchArtistsEventsLogUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  jobId: IntFieldUpdateOperationsInput
  metadata: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SearchArtistsEventsLogUpdateManyWithWhereWithoutArtistInput {
  data: SearchArtistsEventsLogUpdateManyMutationInput!
  where: SearchArtistsEventsLogScalarWhereInput!
}

input SearchArtistsEventsLogUpdateManyWithoutArtistNestedInput {
  connect: [SearchArtistsEventsLogWhereUniqueInput!]
  connectOrCreate: [SearchArtistsEventsLogCreateOrConnectWithoutArtistInput!]
  create: [SearchArtistsEventsLogCreateWithoutArtistInput!]
  createMany: SearchArtistsEventsLogCreateManyArtistInputEnvelope
  delete: [SearchArtistsEventsLogWhereUniqueInput!]
  deleteMany: [SearchArtistsEventsLogScalarWhereInput!]
  disconnect: [SearchArtistsEventsLogWhereUniqueInput!]
  set: [SearchArtistsEventsLogWhereUniqueInput!]
  update: [SearchArtistsEventsLogUpdateWithWhereUniqueWithoutArtistInput!]
  updateMany: [SearchArtistsEventsLogUpdateManyWithWhereWithoutArtistInput!]
  upsert: [SearchArtistsEventsLogUpsertWithWhereUniqueWithoutArtistInput!]
}

input SearchArtistsEventsLogUpdateWithWhereUniqueWithoutArtistInput {
  data: SearchArtistsEventsLogUpdateWithoutArtistInput!
  where: SearchArtistsEventsLogWhereUniqueInput!
}

input SearchArtistsEventsLogUpdateWithoutArtistInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  jobId: IntFieldUpdateOperationsInput
  metadata: JSON
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input SearchArtistsEventsLogUpsertWithWhereUniqueWithoutArtistInput {
  create: SearchArtistsEventsLogCreateWithoutArtistInput!
  update: SearchArtistsEventsLogUpdateWithoutArtistInput!
  where: SearchArtistsEventsLogWhereUniqueInput!
}

input SearchArtistsEventsLogWhereInput {
  AND: [SearchArtistsEventsLogWhereInput!]
  NOT: [SearchArtistsEventsLogWhereInput!]
  OR: [SearchArtistsEventsLogWhereInput!]
  artist: ArtistRelationFilter
  artistId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  jobId: IntFilter
  metadata: JsonFilter
  updatedAt: DateTimeFilter
}

input SearchArtistsEventsLogWhereUniqueInput {
  id: Int
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  mode: QueryMode
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type TrackedArtist {
  artist: Artist!
  artistId: Int!
  createdAt: DateTime!
  id: Int!
  updatedAt: DateTime!
  user: User!
  userId: Int!
}

type TrackedArtistAvgAggregate {
  artistId: Float
  id: Float
  userId: Float
}

input TrackedArtistAvgOrderByAggregateInput {
  artistId: SortOrder
  id: SortOrder
  userId: SortOrder
}

type TrackedArtistCountAggregate {
  _all: Int!
  artistId: Int!
  createdAt: Int!
  id: Int!
  updatedAt: Int!
  userId: Int!
}

input TrackedArtistCountOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input TrackedArtistCreateInput {
  artist: ArtistCreateNestedOneWithoutTrackingsInput!
  createdAt: DateTime
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutTrackedArtistsInput!
}

input TrackedArtistCreateManyArtistInput {
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
  userId: Int!
}

input TrackedArtistCreateManyArtistInputEnvelope {
  data: [TrackedArtistCreateManyArtistInput!]!
  skipDuplicates: Boolean
}

input TrackedArtistCreateManyInput {
  artistId: Int!
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
  userId: Int!
}

input TrackedArtistCreateManyUserInput {
  artistId: Int!
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
}

input TrackedArtistCreateManyUserInputEnvelope {
  data: [TrackedArtistCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input TrackedArtistCreateNestedManyWithoutArtistInput {
  connect: [TrackedArtistWhereUniqueInput!]
  connectOrCreate: [TrackedArtistCreateOrConnectWithoutArtistInput!]
  create: [TrackedArtistCreateWithoutArtistInput!]
  createMany: TrackedArtistCreateManyArtistInputEnvelope
}

input TrackedArtistCreateNestedManyWithoutUserInput {
  connect: [TrackedArtistWhereUniqueInput!]
  connectOrCreate: [TrackedArtistCreateOrConnectWithoutUserInput!]
  create: [TrackedArtistCreateWithoutUserInput!]
  createMany: TrackedArtistCreateManyUserInputEnvelope
}

input TrackedArtistCreateOrConnectWithoutArtistInput {
  create: TrackedArtistCreateWithoutArtistInput!
  where: TrackedArtistWhereUniqueInput!
}

input TrackedArtistCreateOrConnectWithoutUserInput {
  create: TrackedArtistCreateWithoutUserInput!
  where: TrackedArtistWhereUniqueInput!
}

input TrackedArtistCreateWithoutArtistInput {
  createdAt: DateTime
  updatedAt: DateTime
  user: UserCreateNestedOneWithoutTrackedArtistsInput!
}

input TrackedArtistCreateWithoutUserInput {
  artist: ArtistCreateNestedOneWithoutTrackingsInput!
  createdAt: DateTime
  updatedAt: DateTime
}

type TrackedArtistGroupBy {
  _avg: TrackedArtistAvgAggregate
  _count: TrackedArtistCountAggregate
  _max: TrackedArtistMaxAggregate
  _min: TrackedArtistMinAggregate
  _sum: TrackedArtistSumAggregate
  artistId: Int!
  createdAt: DateTime!
  id: Int!
  updatedAt: DateTime!
  userId: Int!
}

input TrackedArtistListRelationFilter {
  every: TrackedArtistWhereInput
  none: TrackedArtistWhereInput
  some: TrackedArtistWhereInput
}

type TrackedArtistMaxAggregate {
  artistId: Int
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
  userId: Int
}

input TrackedArtistMaxOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

type TrackedArtistMinAggregate {
  artistId: Int
  createdAt: DateTime
  id: Int
  updatedAt: DateTime
  userId: Int
}

input TrackedArtistMinOrderByAggregateInput {
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input TrackedArtistOrderByRelationAggregateInput {
  _count: SortOrder
}

input TrackedArtistOrderByWithAggregationInput {
  _avg: TrackedArtistAvgOrderByAggregateInput
  _count: TrackedArtistCountOrderByAggregateInput
  _max: TrackedArtistMaxOrderByAggregateInput
  _min: TrackedArtistMinOrderByAggregateInput
  _sum: TrackedArtistSumOrderByAggregateInput
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  userId: SortOrder
}

input TrackedArtistOrderByWithRelationInput {
  artist: ArtistOrderByWithRelationInput
  artistId: SortOrder
  createdAt: SortOrder
  id: SortOrder
  updatedAt: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum TrackedArtistScalarFieldEnum {
  artistId
  createdAt
  id
  updatedAt
  userId
}

input TrackedArtistScalarWhereInput {
  AND: [TrackedArtistScalarWhereInput!]
  NOT: [TrackedArtistScalarWhereInput!]
  OR: [TrackedArtistScalarWhereInput!]
  artistId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  userId: IntFilter
}

input TrackedArtistScalarWhereWithAggregatesInput {
  AND: [TrackedArtistScalarWhereWithAggregatesInput!]
  NOT: [TrackedArtistScalarWhereWithAggregatesInput!]
  OR: [TrackedArtistScalarWhereWithAggregatesInput!]
  artistId: IntWithAggregatesFilter
  createdAt: DateTimeWithAggregatesFilter
  id: IntWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
  userId: IntWithAggregatesFilter
}

type TrackedArtistSumAggregate {
  artistId: Int
  id: Int
  userId: Int
}

input TrackedArtistSumOrderByAggregateInput {
  artistId: SortOrder
  id: SortOrder
  userId: SortOrder
}

input TrackedArtistUpdateInput {
  artist: ArtistUpdateOneRequiredWithoutTrackingsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTrackedArtistsNestedInput
}

input TrackedArtistUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TrackedArtistUpdateManyWithWhereWithoutArtistInput {
  data: TrackedArtistUpdateManyMutationInput!
  where: TrackedArtistScalarWhereInput!
}

input TrackedArtistUpdateManyWithWhereWithoutUserInput {
  data: TrackedArtistUpdateManyMutationInput!
  where: TrackedArtistScalarWhereInput!
}

input TrackedArtistUpdateManyWithoutArtistNestedInput {
  connect: [TrackedArtistWhereUniqueInput!]
  connectOrCreate: [TrackedArtistCreateOrConnectWithoutArtistInput!]
  create: [TrackedArtistCreateWithoutArtistInput!]
  createMany: TrackedArtistCreateManyArtistInputEnvelope
  delete: [TrackedArtistWhereUniqueInput!]
  deleteMany: [TrackedArtistScalarWhereInput!]
  disconnect: [TrackedArtistWhereUniqueInput!]
  set: [TrackedArtistWhereUniqueInput!]
  update: [TrackedArtistUpdateWithWhereUniqueWithoutArtistInput!]
  updateMany: [TrackedArtistUpdateManyWithWhereWithoutArtistInput!]
  upsert: [TrackedArtistUpsertWithWhereUniqueWithoutArtistInput!]
}

input TrackedArtistUpdateManyWithoutUserNestedInput {
  connect: [TrackedArtistWhereUniqueInput!]
  connectOrCreate: [TrackedArtistCreateOrConnectWithoutUserInput!]
  create: [TrackedArtistCreateWithoutUserInput!]
  createMany: TrackedArtistCreateManyUserInputEnvelope
  delete: [TrackedArtistWhereUniqueInput!]
  deleteMany: [TrackedArtistScalarWhereInput!]
  disconnect: [TrackedArtistWhereUniqueInput!]
  set: [TrackedArtistWhereUniqueInput!]
  update: [TrackedArtistUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [TrackedArtistUpdateManyWithWhereWithoutUserInput!]
  upsert: [TrackedArtistUpsertWithWhereUniqueWithoutUserInput!]
}

input TrackedArtistUpdateWithWhereUniqueWithoutArtistInput {
  data: TrackedArtistUpdateWithoutArtistInput!
  where: TrackedArtistWhereUniqueInput!
}

input TrackedArtistUpdateWithWhereUniqueWithoutUserInput {
  data: TrackedArtistUpdateWithoutUserInput!
  where: TrackedArtistWhereUniqueInput!
}

input TrackedArtistUpdateWithoutArtistInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutTrackedArtistsNestedInput
}

input TrackedArtistUpdateWithoutUserInput {
  artist: ArtistUpdateOneRequiredWithoutTrackingsNestedInput
  createdAt: DateTimeFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input TrackedArtistUpsertWithWhereUniqueWithoutArtistInput {
  create: TrackedArtistCreateWithoutArtistInput!
  update: TrackedArtistUpdateWithoutArtistInput!
  where: TrackedArtistWhereUniqueInput!
}

input TrackedArtistUpsertWithWhereUniqueWithoutUserInput {
  create: TrackedArtistCreateWithoutUserInput!
  update: TrackedArtistUpdateWithoutUserInput!
  where: TrackedArtistWhereUniqueInput!
}

input TrackedArtistWhereInput {
  AND: [TrackedArtistWhereInput!]
  NOT: [TrackedArtistWhereInput!]
  OR: [TrackedArtistWhereInput!]
  artist: ArtistRelationFilter
  artistId: IntFilter
  createdAt: DateTimeFilter
  id: IntFilter
  updatedAt: DateTimeFilter
  user: UserRelationFilter
  userId: IntFilter
}

input TrackedArtistWhereUniqueInput {
  id: Int
}

type User {
  _count: UserCount
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  password: String!
  profileImg: String
  spotifyId: String!
  trackedArtists(cursor: TrackedArtistWhereUniqueInput, distinct: [TrackedArtistScalarFieldEnum!], orderBy: [TrackedArtistOrderByWithRelationInput!], skip: Int, take: Int, where: TrackedArtistWhereInput): [TrackedArtist!]!
  updatedAt: DateTime!
}

type UserAvgAggregate {
  id: Float
}

input UserAvgOrderByAggregateInput {
  id: SortOrder
}

type UserCount {
  trackedArtists: Int!
}

type UserCountAggregate {
  _all: Int!
  createdAt: Int!
  email: Int!
  id: Int!
  name: Int!
  password: Int!
  profileImg: Int!
  spotifyId: Int!
  updatedAt: Int!
}

input UserCountOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  updatedAt: SortOrder
}

input UserCreateInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  profileImg: String
  spotifyId: String!
  trackedArtists: TrackedArtistCreateNestedManyWithoutUserInput
  updatedAt: DateTime
}

input UserCreateManyInput {
  createdAt: DateTime
  email: String!
  id: Int
  name: String!
  password: String!
  profileImg: String
  spotifyId: String!
  updatedAt: DateTime
}

input UserCreateNestedOneWithoutTrackedArtistsInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTrackedArtistsInput
  create: UserCreateWithoutTrackedArtistsInput
}

input UserCreateOrConnectWithoutTrackedArtistsInput {
  create: UserCreateWithoutTrackedArtistsInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutTrackedArtistsInput {
  createdAt: DateTime
  email: String!
  name: String!
  password: String!
  profileImg: String
  spotifyId: String!
  updatedAt: DateTime
}

type UserGroupBy {
  _avg: UserAvgAggregate
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  _sum: UserSumAggregate
  createdAt: DateTime!
  email: String!
  id: Int!
  name: String!
  password: String!
  profileImg: String
  spotifyId: String!
  updatedAt: DateTime!
}

type UserMaxAggregate {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
  profileImg: String
  spotifyId: String
  updatedAt: DateTime
}

input UserMaxOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  updatedAt: SortOrder
}

type UserMinAggregate {
  createdAt: DateTime
  email: String
  id: Int
  name: String
  password: String
  profileImg: String
  spotifyId: String
  updatedAt: DateTime
}

input UserMinOrderByAggregateInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithAggregationInput {
  _avg: UserAvgOrderByAggregateInput
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  _sum: UserSumOrderByAggregateInput
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  updatedAt: SortOrder
}

input UserOrderByWithRelationInput {
  createdAt: SortOrder
  email: SortOrder
  id: SortOrder
  name: SortOrder
  password: SortOrder
  profileImg: SortOrder
  spotifyId: SortOrder
  trackedArtists: TrackedArtistOrderByRelationAggregateInput
  updatedAt: SortOrder
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  createdAt
  email
  id
  name
  password
  profileImg
  spotifyId
  updatedAt
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  email: StringWithAggregatesFilter
  id: IntWithAggregatesFilter
  name: StringWithAggregatesFilter
  password: StringWithAggregatesFilter
  profileImg: StringNullableWithAggregatesFilter
  spotifyId: StringWithAggregatesFilter
  updatedAt: DateTimeWithAggregatesFilter
}

type UserSumAggregate {
  id: Int
}

input UserSumOrderByAggregateInput {
  id: SortOrder
}

input UserUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  profileImg: NullableStringFieldUpdateOperationsInput
  spotifyId: StringFieldUpdateOperationsInput
  trackedArtists: TrackedArtistUpdateManyWithoutUserNestedInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  profileImg: NullableStringFieldUpdateOperationsInput
  spotifyId: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutTrackedArtistsNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutTrackedArtistsInput
  create: UserCreateWithoutTrackedArtistsInput
  update: UserUpdateWithoutTrackedArtistsInput
  upsert: UserUpsertWithoutTrackedArtistsInput
}

input UserUpdateWithoutTrackedArtistsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  email: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  password: StringFieldUpdateOperationsInput
  profileImg: NullableStringFieldUpdateOperationsInput
  spotifyId: StringFieldUpdateOperationsInput
  updatedAt: DateTimeFieldUpdateOperationsInput
}

input UserUpsertWithoutTrackedArtistsInput {
  create: UserCreateWithoutTrackedArtistsInput!
  update: UserUpdateWithoutTrackedArtistsInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  createdAt: DateTimeFilter
  email: StringFilter
  id: IntFilter
  name: StringFilter
  password: StringFilter
  profileImg: StringNullableFilter
  spotifyId: StringFilter
  trackedArtists: TrackedArtistListRelationFilter
  updatedAt: DateTimeFilter
}

input UserWhereUniqueInput {
  id: Int
}
